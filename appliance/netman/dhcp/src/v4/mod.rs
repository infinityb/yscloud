
#[cfg(test)]
mod tests {
    use binhelpers::rhexdump;

    static DHCP_SAMPLE_RESPONSE: &[u8] = rhexdump!(r#"
        0000   02 01 06 00 c7 ea fb ae 00 00 00 00 4b 9f 2e 3f   ............K..?
        0010   4b 9f 2e 3f 0a 98 d3 0d 00 00 00 00 00 50 04 b1   K..?.........P..
        0020   ad 23 00 00 00 00 00 00 00 00 00 00 00 00 00 00   .#..............
        0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00a0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00e0   00 00 00 00 00 00 00 00 00 00 00 00 63 82 53 63   ............c.Sc
        00f0   35 01 05 36 04 0a 98 d3 0d 33 04 00 00 38 40 01   5..6.....3...8@.
        0100   04 ff ff fc 00 03 04 4b 9f 2c 01 06 08 4b 99 b0   .......K.,...K..
        0110   01 4b 99 ab 72 0c 05 6b 79 72 69 65 ff 00 00 00   .K..r..kyrie....
        0120   00 00 00 00 00 00 00 00 00 00 00 00               ............
    "#);

    static DHCP_SAMPLE_REQUEST: &[u8] = rhexdump!(r#"
        0000   01 01 06 00 c7 ea fb ae 00 00 00 00 4b 9f 2e 3f   ............K..?
        0010   00 00 00 00 00 00 00 00 00 00 00 00 00 50 04 b1   .............P..
        0020   ad 23 00 00 00 00 00 00 00 00 00 00 00 00 00 00   .#..............
        0030   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0050   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0060   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0070   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0090   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00a0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00d0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        00e0   00 00 00 00 00 00 00 00 00 00 00 00 63 82 53 63   ............c.Sc
        00f0   35 01 03 3d 07 01 00 50 04 b1 ad 23 0c 05 6b 79   5..=...P...#..ky
        0100   72 69 65 37 0a 01 1c 02 79 03 0f 06 0c 77 1a ff   rie7....y....w..
        0110   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
        0120   00 00 00 00 00 00 00 00 00 00 00 00               ............
    "#);

    #[test]
    fn it_works() {
        return;
        panic!("DHCP_SAMPLE_REQUEST = {:?}", DHCP_SAMPLE_REQUEST);
        assert_eq!(2 + 2, 4);
    }
}


// type DhcpResult<T> = Result<T, anyhow::Error>;

// struct DhcpRequestConfig {
//     op: u8,
//     htype: u8,
//     hlen: u8,
//     hops: u8,
//     xid: u32,
//     secs: u16,
//     flags: u16,
//     ciaddr: u32,
//     yiaddr: u32,
//     siaddr: u32,
//     giaddr: u32,
//     chaddr: u32,

// }

// pub fn deserialize_request(data: &[u8]) -> anyhow::Result<DhcpRequestConfig> {
//     /
// }

// pub fn serialize_request<'a>(scratch: &'a mut [u8], config: &DhcpRequestConfig) -> Option<&'a [u8]> {
//     Some(&[])
// }

